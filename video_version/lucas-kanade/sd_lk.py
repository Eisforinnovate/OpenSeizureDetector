#!/usr/bin/env python
"""
Investigating using the lucas-kanade motion tracking method for the 
seizure detector.
Based on the lkdemo.py file provided with openCV
"""

import sys
import datetime
import math
import numpy, scipy, scipy.fftpack
import pylab

# import the necessary things for OpenCV
import cv2.cv as cv


class sd_lk:
    """ Class wrapper around the lucas-kanade seizure detector code.
    """
    inputfps = 30  # limit sample rate to 30 fps.
    outputfps = inputfps
    win_size = 10
    MAX_COUNT = 30
    Analysis_Period =2 # Seconds (period between analysing time series)
    Feature_Search_Period = 60 # Seconds (period between re-acquiring features to track)
    FFT_AMPL_THRESH = 50  # Threshold amplitude to detect movement (pixels/sec)
    X11 = True  # Whether to display the images usin Xwindows or not.

    plotFeatureNo = 0


    # the default parameters for initFeatures()
    #quality = 0.01
    #quality = 0.3
    quality = 0.1
    # min_distance = 65
    min_distance = 20

    # Settings for alarm initiation
    alarmAmplThresh = 100
    alarmFreqMin = 4   # minimum frequency bin number for alarm
    alarmFreqMax = 10  # maximum frequency bin number for alarm
    alarmWarnPeriod = 10 # number of seconds to be above threshold before warning
    alarmAlarmPeriod = 20 # mumber of seconds to be above threshold before initiating alarm.

    alarmThreshExceededTime = []  # Time that the threshold was exceeded (None if below threshold

    image = None
    pt = None
    flags = 0
    need_to_init = True
    last_frame_time = None
    last_analysis_time = None

    timeSeries = []

    def __init__(self):
        """ 
        Create an instance of the seizure detector class.
        This just initialises the de-bugging grap windows.
        """
        self.fig = pylab.figure(None,(5,7),96)
        self.ax1 = self.fig.add_subplot(311)
        self.ax2 = self.fig.add_subplot(312)
        self.ax3 = self.fig.add_subplot(313)
        self.fig.canvas.draw()
        self.freqChart = None
        self.timeChart = None
        self.fftImg = None
        self.colorbar = None
        pylab.ion()


    def initFeatures(self,grey):
        """
        Take the grey scale image 'grey' and look for suitable features
        to track.  Returns a list of features generated by the OpenCV
        GoodFeaturesToTrack() function.
        """
        print "initFeatures()"
        # cv.ShowImage ('initFeatures() grey',grey)
        # Reset the frequency analysis data, as we are going to track new features.
        eig = cv.CreateImage (cv.GetSize (grey), 32, 1)
        temp = cv.CreateImage (cv.GetSize (grey), 32, 1)
        mask = cv.CreateImage (cv.GetSize (grey), 8, 1)    

        # Create a mask image to hide the top 10% of the image (which contains text)
        (w,h) = cv.GetSize(grey)
        cv.Rectangle(mask,(0,0),(w,h),cv.Scalar(255,0,0),-1)
        cv.Rectangle(mask,(0,0),(w,int(0.1*h)),cv.Scalar(0,0,0),-1)
        # cv.ShowImage ('mask',mask)

        # search for the good points
        self.features = cv.GoodFeaturesToTrack (
            grey, eig, temp,
            self.MAX_COUNT,
            self.quality, self.min_distance, mask, 3, 0, 0.04)

        print "found %d features (MAX_COUNT=%d)" % (len(self.features),self.MAX_COUNT)

        # refine the corner locations
        self.features = cv.FindCornerSubPix (
            grey,
            self.features,
            (self.win_size, self.win_size),  (-1, -1),
            (cv.CV_TERMCRIT_ITER | cv.CV_TERMCRIT_EPS, 20, 0.03))

        self.alarmThreshExceededTime = []
        self.alarmActive = []
        for featNo in range (len(self.features)):
            self.alarmThreshExceededTime.append(None)
            self.alarmActive.append(0)

        if (len(self.features)==0):
            print "***WARNING - No Features found in Image***"
            return False
        else:
            return True
    # init_features()

    def ptptdist(self,p0,p1):
        """
        Returns the distance in pixels between two (x,y) points.
        """
        return math.sqrt(self.ptptdist2(p0,p1))

    def ptptdist2(self,p0, p1):
        """ Return the distance^2 between two points. """
        dx = p0[0] - p1[0]
        dy = p0[1] - p1[1]
        return dx**2 + dy**2


    def doPlot(self,dataMat,fftMat,times):
        """
        Produce the debugging graphs.
        """
        pixelNo = self.plotFeatureNo
        sampleFft = []
        freqs = []
        vals = []
        nSamples,nFeatures = cv.GetSize(dataMat)
        if (nFeatures-1<pixelNo):
            pixelNo = nFeatures-1
        freqBinWidth = 1.0/(times[len(times)-1]-times[0]);
        for x in range(nSamples):
            freq = 1.0*x*freqBinWidth
            freqs.append(freq)
            sampleFft.append(abs(fftMat[pixelNo,x]))
            vals.append(dataMat[pixelNo,x])

        print "len(times)=%d, len(vals)=%d" % (len(times),len(vals))


        # Throw away the DC component to help with scaling the graph.
        sampleFft[0]=0

        # Now plot the graphs
        pylab.title("")
        self.ax1.clear()
        self.timeChart, = self.ax1.plot(times,vals)
        self.ax1.set_title("Feature Number %d" % (pixelNo))
        self.ax1.set_xlabel("time (sec)")
        self.ax1.set_ylabel("vel (pix/sec)")

        self.ax2.clear()
        self.freqChart, = self.ax2.plot(freqs,sampleFft)
        self.ax2.set_xlabel("freq (Hz)")
        self.ax2.set_ylabel("amplitude (pix)")

        self.ax3.clear()
        self.fftImg = self.ax3.imshow(fftMat,aspect='auto')
        # self.fftImg.set_cmap('prism')
        self.ax3.set_xlabel("freq bin no")
        self.ax3.set_ylabel("PixelNo")
        if (self.colorbar == None):
            self.colorbar = self.fig.colorbar(self.fftImg)

        self.fig.canvas.draw()
        print "doPlot done"



    def doAnalysis(self):
        """
        Analyse the time series motion of the features being tracked
        to look for ones which are oscillating, which could indicate a
        seizure
        """
        nSamples = len(self.timeSeries)
        nFeatures = len(self.timeSeries[0][1])
        print "doAnalysis() - nSamples = %d, nFeatures = %d" % (nSamples,nFeatures)

        # Create a matrix with feature speeds in the y direction, 
        # and time (frame no) in the x direction.   
        # This means we can do an FFT on each row to get
        # frequency components of each feature.
        dataMat = cv.CreateMat(nFeatures,nSamples-1,cv.CV_32FC1)
        times = []
        for frameNo in range(nSamples-1):
            dt = (self.timeSeries[frameNo+1][0] - self.timeSeries[frameNo][0]).total_seconds()
            if (frameNo==0):
                times.append(dt)
            else:
                times.append(times[frameNo-1]+dt)
            for featNo in range(nFeatures):
                ds = self.ptptdist(self.timeSeries[frameNo][1][featNo],
                              self.timeSeries[frameNo+1][1][featNo])
                v = ds/dt
                # set the direction
                #if(self.timeSeries[frameNo][1][featNo][1] >
                #   self.timeSeries[frameNo+1][1][featNo][1]):
                #    v*=-1
                dataMat[featNo,frameNo] = v

        #cv.ShowImage("dataMat",dataMat)

        self.fftMat = cv.CreateMat(nFeatures,nSamples-1,cv.CV_32FC1)
        cv.DFT(dataMat,self.fftMat,cv.CV_DXT_ROWS)
        #cv.ShowImage("fft",self.fftMat)

        if (self.X11): self.doPlot(dataMat,self.fftMat,times)

        # Look for the dominant frequency of each feature.
        freqBinSize = 1.0/(times[len(times)-1]-times[0]);
        print "freqBinSize = %f Hz" % (freqBinSize)
        self.maxAmpl = numpy.zeros((nFeatures))
        self.maxFreq = numpy.zeros((nFeatures))
        for featNo in range(nFeatures):
            self.maxAmpl[featNo] = self.FFT_AMPL_THRESH
            self.maxFreq[featNo] = 0
            for freqBin in range(1,nSamples/2):
                if (self.fftMat[featNo,freqBin]>self.maxAmpl[featNo]):
                    self.maxAmpl[featNo] = self.fftMat[featNo,freqBin]
                    self.maxFreq[featNo] = freqBinSize*freqBin
        self.timeSeries = []
        return True
    # doAnalysis()


    def doAlarmCheck(self):
        """ Check analysed data to see if we need to raise or reset an alarm.
        """
        print "doAlarmCheck()"
        nSamples,nFeatures = cv.GetSize(self.fftMat)
        tNow = datetime.datetime.now()
        for featNo in range(nFeatures):
            alarmState = False
            for freqBin in range(self.alarmFreqMin,self.alarmFreqMax):
                if (self.fftMat[featNo,freqBin]>self.alarmAmplThresh):
                    alarmState = True
            if (alarmState):
                if (self.alarmThreshExceededTime[featNo] == None):
                    print "Threshold Exceeded on Feature %d" % (featNo)
                    self.alarmThreshExceededTime[featNo] = tNow
                if ((tNow - self.alarmThreshExceededTime[featNo])\
                        .total_seconds()>=self.alarmWarnPeriod):
                    if ((tNow - self.alarmThreshExceededTime[featNo])\
                            .total_seconds()>=self.alarmAlarmPeriod):
                        print "*****ALARM ON FEATURE %d, Amplitude = %f ******"\
                            % (featNo,self.maxAmpl[featNo])
                        self.alarmActive[featNo] = 2
                    else:
                        print "*****Warning on feature %d, Amplitude = %f *****"\
                            % (featNo,self.maxAmpl[featNo])
                        self.alarmActive[featNo] = 1
            else:
                if (self.alarmThreshExceededTime[featNo] != None):
                    print "Alarm Reset on Feature %d" % (featNo)
                    self.alarmThreshExceededTime[featNo] = None
                self.alarmActive[featNo] = 0
    # doAlarmCheck()
        
    def onTrackbarChanged(self,value):
        print "onTrackbarChanged - value=%d" % (value)
        self.plotFeatureNo = value

    def sd_loop(self):
        """
        The main seizure detector loop - call this function to start
        the seizure detector.
        """
        self.timeSeries = []  # array of times that data points were collected.
        self.maxFreq = None
        if (self.X11): 
            cv.NamedWindow ('Seizure_Detector', cv.CV_WINDOW_AUTOSIZE)
            cv.CreateTrackbar('FeatureTrackbar','Seizure_Detector',
                              0,self.MAX_COUNT,self.onTrackbarChanged)
        font = cv.InitFont(cv.CV_FONT_HERSHEY_SIMPLEX, 0.5, 0.5, 0, 1, 8) 

        # Intialise the video input source 
        # ('camera' - may be a file or network stream though).
        camera = cv.CaptureFromFile("rtsp://192.168.1.18/live_mpeg4.sdp")
        #camera = cv.CaptureFromFile("../testcards/testcard.mpg")
        #camera = cv.CaptureFromFile("/home/graham/Videos/sample5.mp4")
        #camera = cv.CaptureFromCAM(0)

        # Set the VideoWriter that produces the output video file.
        frameSize = (640,480)
        videoFormat = cv.FOURCC('p','i','m','1')
        # videoFormat = cv.FOURCC('l','m','p','4')
        vw = cv.CreateVideoWriter("seizure_test.mpg",videoFormat, self.outputfps,frameSize,1)
        if (vw == None):
            print "ERROR - Failed to create VideoWriter...."

        # Get the first frame.
        last_analysis_time = datetime.datetime.now()
        last_feature_search_time = datetime.datetime.now()
        last_frame_time = datetime.datetime.now()
        frame = cv.QueryFrame(camera)

        # Main loop - repeat forever
        while 1:
            # Carry out initialisation, memory allocation etc. if necessary
            if self.image is None:   
                self.image = cv.CreateImage (cv.GetSize (frame), 8, 3)
                self.image.origin = frame.origin
                grey = cv.CreateImage (cv.GetSize (frame), 8, 1)
                prev_grey = cv.CreateImage (cv.GetSize (frame), 8, 1)
                pyramid = cv.CreateImage (cv.GetSize (frame), 8, 1)
                prev_pyramid = cv.CreateImage (cv.GetSize (frame), 8, 1)
                self.features = []

            # copy the captured frame to our self.image object.
            cv.Copy (frame, self.image)

            # create a grey version of the image
            cv.CvtColor (self.image, grey, cv.CV_BGR2GRAY)

            # Look for features to track.
            if self.need_to_init:
                #cv.ShowImage ('loop_grey',grey)
                self.initFeatures(grey)
                self.timeSeries = []
                self.maxFreq = None
                last_analysis_time = datetime.datetime.now()
                self.need_to_init = False

            # Now track the features, if we have some.
            if self.features != []:
                # we have points to track, so track them and add them to
                # our time series of positions.
                self.features, status, track_error = cv.CalcOpticalFlowPyrLK (
                    prev_grey, grey, prev_pyramid, pyramid,
                    self.features,
                    (self.win_size, self.win_size), 3,
                    (cv.CV_TERMCRIT_ITER|cv.CV_TERMCRIT_EPS, 20, 0.03),
                    self.flags)
                self.timeSeries.append( (last_frame_time,self.features) )
                # and plot them.
                for featNo in range(len(self.features)):
                    pointPos = self.features[featNo]
                    cv.Circle (self.image, 
                               (int(pointPos[0]), int(pointPos[1])), 
                               3, (0, 255, 0, 0), -1, 8, 0)
                    if (self.alarmActive[featNo]==2):
                        cv.Circle (self.image, 
                                   (int(pointPos[0]), int(pointPos[1])), 
                                   10, (0, 0, 255, 0), 5, 8, 0)
                    if (self.alarmActive[featNo]==1):
                        cv.Circle (self.image, 
                                   (int(pointPos[0]), int(pointPos[1])), 
                                   10, (0, 0, 255, 0), 2, 8, 0)

                    # there will be no maxFreq data until we have 
                    # run doAnalysis for the first time.
                    if (not self.maxFreq == None):
                        msg = "%d-%3.1f" % (featNo,self.maxFreq[featNo])
                        cv.PutText(self.image,
                                   msg, 
                                   (int(pointPos[0]+5),int(pointPos[1]+5)),
                                   font, (255,255,255)) 
                # end of for loop over features
            else:
                #print "Oh no, no features to track, and you haven't told me to look for more."
                # no features, so better look for some more...
                self.need_to_init = True

            # Is it time to analyse the captured time series.
            if ((datetime.datetime.now() - last_analysis_time).total_seconds() 
                > self.Analysis_Period):
                if (len(self.timeSeries)>0):
                    self.doAnalysis()
                    self.doAlarmCheck()
                    last_analysis_time = datetime.datetime.now()
                else:
                    # print "Not doing analysis - no time series data..."
                    a = True

            # Is it time to re-acquire the features to track.
            if ((datetime.datetime.now() - last_feature_search_time).total_seconds() 
                > self.Feature_Search_Period):
                print "resetting..."
                last_feature_search_time = datetime.datetime.now()
                self.need_to_init = True


            # save current data for use next time around.
            prev_grey, grey = grey, prev_grey
            prev_pyramid, pyramid = pyramid, prev_pyramid

            # we can now display the image
            if (self.X11): cv.ShowImage ('Seizure_Detector', self.image)
            cv.WriteFrame(vw,self.image)

            # handle events
            c = cv.WaitKey(10)
            if c == 27:
                # user has press the ESC key, so exit
                break

            # Control frame rate by pausing if we are going too fast.
            frameTime = (datetime.datetime.now() - last_frame_time)\
                .total_seconds()
            actFps = 1.0/frameTime
            if (frameTime < 1/self.inputfps):
                cv.WaitKey(1+int(1000.*(1./self.inputfps - frameTime)))

            # Grab the next frame
            last_frame_time = datetime.datetime.now()
            frame = cv.QueryFrame(camera)
    # End of main loop

if __name__ == '__main__':
    print "Lucas-Kanade version of seizure detector"
    sd = sd_lk()
    sd.sd_loop()

       # End of main loop.
